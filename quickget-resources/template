#!/usr/bin/env bash

RESOURCE_DIR="$(dirname "${0}")"

# Instructions: 
# 1. Set necessary variables below
# 2. Modify fetch_info function to include all of the necessary information (or way to fetch it)
# 3. Modify list_urls function to provide ISO(s) for the operating system

# (REQUIRED) Homepage of the operating system (URL)
readonly HOMEPAGE=""
# (OPTIONAL) Brief description of the operating system
readonly DESCRIPTION=""
# (OPTIONAL) Set this to the friendly name of the operating system, if applicable. 
PRETTY_NAME=""
# Set this to 1 if the operating system has unique editions (which you will set) for each release, 0 otherwise
readonly UNIQUE_EDITIONS=0
# Set this variable depending on whether or not the operating system requires an edition to be specified
readonly REQUIRES_EDITION=0
# If an edition is NOT required but multiple editions ARE available, put the default edition's name here.
readonly DEFAULT_EDITION=""
# If the operating system has a unique name for its editions (i.e. Windows: Languages), set it here
EDITION_NAME=""
# Set this to 1 if your fetch_info function fetches data from the internet, 0 if it's hardcoded
readonly CACHE_DATA=0
# Add all valid architectures for your operating system here. The first one in the array will be the default (if host system does not match)
# Use the most standard name for each architecture. Example: amd64, arm64, riscv64, i386. NOT: x86_64, aarch64, x86, riscv.
readonly ARCHITECTURES=(amd64)


function fetch_info() {
    # Add editions and releases here. Or, replace this with your code to fetch releases and editions.
    # Add them to the array with the += operator followed by parentheses.
    RELEASES+=()
    # You may leave EDITIONS blank if there is only one edition.
    EDITIONS+=()

    # If unique editions are required per release, use this template.
    # You may still put static editions (those which are present for ALL releases) in the EDITIONS array 
    # associativeEDITIONS['RELEASE1']="EDITION1;EDITION2;EDITION3"
    # associativeEDITIONS['RELEASE2']="EDITION1;EDITION2;EDITION3"
}

function list_urls() {
    fetch_from_cache

    # Here, you can insert the URL, ISO, and HASH, similarly to the original quickget.
    # Alternatively, you may replace it with anything else, or call another function you create if necessary.
    local URL=""
    local ISO=""
    local HASH=""

    # These are default options. You may change them if necessary. If multiple files need to be downloaded,
    # they may be separated by a space, with hashes (if applicable) following the applicable files (once again, separated by a space).
    # If you need to handle downloading within this function, call whatever method you'd like, and then add 'exit 2' so quickget knows to skip download.
    case "${2}" in
        # Friendly is the show_iso_url option. It should print the URL(s) in a way that's easily readable, and not hashes
        --friendly)
            echo "${URL}/${ISO}";;
        --download)
            echo "${URL}/${ISO}" "${HASH}";;
    esac
}

function config_additions() {
    # SPECIFICS TBD


    # Here, you can add any additional configuation options that should be included in the VM config.
    # Just echo them out (in quotation marks) if you want to append them to the other options.
    # append "OVERRIDE " to the beginning of the string to instead replace the value of a default option.
    # Example: echo "OVERRIDE guest_os=macos" to replace the default linux option with macos
    # You can REMOVE options by echoing "REMOVE " followed by the option name. 
    # Example: echo "REMOVE disk_size" to remove the disk_size option, such as for macOS VMs which have disk_size handled in quickemu
    exit 0
}

# Everything below here should not have to be modified. Variables above are used to determine the proper behavior
# I'm expecting to move most of this to a separate file which will be run with `source`, but it'll remain here until functional
function validate_re() {
    fetch_from_cache
    
    if [ -z "${RELEASE}" ]; then
        echo "ERROR! You must specify a release."
        format_re
        exit 1
    fi

    # Check if release is present in the releases array
    for REL in "${RELEASES[@]}"; do
        if [ "${RELEASE,,}" == "${REL,,}" ]; then
            # Handle unnecessary editions passed
            if [ -z "${EDITIONS[*]}" ] && [ -n "${EDITION}" ]; then
                echo "WARNING: ${PRETTY_NAME} does not support ${EDITION_NAME,,}. Ignoring."
                exit 2
            elif [ -z "${EDITION}" ] && [ "${REQUIRES_EDITION}" -eq 0 ]; then
                exit 2
            elif [ -z "${EDITION}" ] && [ "${REQUIRES_EDITION}" -eq 1 ]; then
                echo -en "ERROR: You must specify an edition.\n - ${PRETTY_NAME} ${RELEASE} Editions: "
                list_editions "${ARCH}" "${RELEASE}"
                exit 1
            fi

            # Handle the associative array for unique editions
            if [ "${UNIQUE_EDITIONS}" -eq 1 ]; then
                while read -d ';' -r aEDITION; do
                    EDITIONS+=("${aEDITION}")
                done <<< "${associativeEDITIONS["${RELEASE}"]};"
            fi

            # Loop through editions array and check if the edition is present
            for ED in "${EDITIONS[@]}"; do
                if [ "${EDITION,,}" == "${ED,,}" ]; then
                    exit 0
                fi
            done

            echo -e "ERROR! ${EDITION} is not a supported ${PRETTY_NAME} ${RELEASE} edition.\n"
            list_editions "${ARCH}" "${RELEASE}"
            exit 1
        fi
    done

    echo "ERROR! ${PRETTY_NAME} ${RELEASE} is not a supported release."
    format_re 
    exit 1
}

function format_re() {
    if [ "${UNIQUE_EDITIONS}" -eq 1 ]; then
        echo PLACEHOLDER
    else
        echo " - Releases: " "${RELEASES[@]}"
        if [ -n "${EDITIONS[*]}" ]; then
            echo " - Editions: " "${EDITIONS[@]}"
        fi
    fi
}

function list_editions() {
    # Handle the associative array for unique editions
    if [ "${UNIQUE_EDITIONS}" -eq 1 ]; then
        while read -d ';' -r aEDITION; do
            EDITIONS+=("${aEDITION}")
        done <<< "${associativeEDITIONS["${RELEASE}"]};"
    fi
    echo "${EDITIONS[@]}"
}

function fetch_from_cache() {
    if [[ "${CACHE_DATA}" == 0 ]]; then
        fetch_info 
        return 0
    # TODO: Determine whether cache exists and contains up to date data. 
    elif [ true ]; then
        fetch_info
        populate_cache
        return 0
    fi

    echo PLACEHOLDER
}

function populate_cache() {
    # Populate cache with JSON data, to be read by fetch_from_cache function
    echo PLACEHOLDER
}

function verify_arch() {
    for ARCHITECTURE in "${ARCHITECTURES[@]}"; do
        if [ "${ARCHITECTURE}" == "${ARCH}" ]; then
            return 0
        fi
    done
    ARCH="${ARCHITECTURES[0]}"
}

# Set default values (should not edit)
PRETTY_NAME="${PRETTY_NAME:-${OS}}"
EDITION_NAME="${EDITION_NAME:-Editions}"
CACHE_FILE="${HOME}/.cache/quickget/${OS}.cache"
declare -A associativeEDITIONS

verify_arch

case "${1}" in
    --homepage)
        echo "${HOMEPAGE}";;
    --edition-name)
        echo "${EDITION_NAME}";;
    --unique-editions)
        return "${UNIQUE_EDITIONS}";;
    --pretty-name)
        return "${PRETTY_NAME}";;
    --return-arch)
        echo "${ARCH}";;
    --description)
        echo "${DESCRIPTION}";;
    --refresh)
        if [ "${CACHE_DATA}" -eq 1 ]; then
            fetch_info
            populate_cache
        fi;;
    --validate-re)
        validate_re "${@}";;
    --list-urls)
        list_urls "${@}";;
esac

# vim:tabstop=4:shiftwidth=4:expandtab