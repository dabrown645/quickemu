#!/usr/bin/env bash

RESOURCE_DIR="$(dirname "${0}")"

# Instructions: 
# 1. Set necessary variables below
# 2. Modify fetch_info function to include all of the necessary information (or way to fetch it)

# (REQUIRED) Homepage of the operating system (URL)
HOMEPAGE=""
# (OPTIONAL) Brief description of the operating system
DESCRIPTION=""
# (OPTIONAL) Set this to the friendly name of the operating system, if applicable. 
PRETTY_NAME=""
# Set this to 1 if the operating system has unique editions (which you will set) for each release, 0 otherwise
UNIQUE_EDITIONS=0
# Set this variable depending on whether or not the operating system requires an edition to be specified
REQUIRES_EDITION=0
# If an edition is NOT required but multiple editions ARE available, put the default edition's name here.
DEFAULT_EDITION=""
# If the operating system has a unique name for its editions (i.e. Windows: Languages), set it here
EDITION_NAME=""
# Set this to 1 if your fetch_info function fetches data from the internet, 0 if it's hardcoded
CACHE_DATA=0


function fetch_info() {
    # Sets the architecture based on input, fetch OS data from cache if available.
    case "${1}" in
        --refresh)
            ARCH="${2}";;
        *)
            fetch_from_cache && return 0;;
    esac

    # Add editions and releases here. Or, replace this with your code to fetch releases and editions.
    # Add them to the array with the += operator followed by parentheses.
    RELEASES+=()
    # You may leave EDITIONS blank if there is only one edition.
    EDITIONS+=()

    # If unique editions are required, use this template instead. 
    # You may still put static editions (those which are present for ALL releases) in the EDITIONS array 
    # declare -A associativeEDITIONS
    # associativeEDITIONS['RELEASE1']="EDITION1;EDITION2;EDITION3"
    # associativeEDITIONS['RELEASE2']="EDITION1;EDITION2;EDITION3"

    if [ "${CACHE_DATA}" -eq 1 ]; then
        populate_cache "${ARCH}"
    fi
}

function list_urls() {
    ARCH="${3}"
    fetch_info
    local RELEASE="${4}"
    local EDITION="${5}"

    # Here, you can insert the URL, ISO, and HASH, similarly to the original quickget.
    # Alternatively, you may replace it with anything else, or call another function you create if necessary.
    local URL=""
    local ISO=""
    local HASH=""

    # These are default options. You may change them if necessary. If multiple files need to be downloaded,
    # they may be separated by a space, with hashes (if applicable) following the applicable files (once again, separated by a space).
    # If you need to handle downloading within this function, call whatever method you'd like, and then add 'exit 2' so quickget knows to skip download.
    case "${2}" in
        # Friendly is the show_iso_url option. It should print the URL(s) in a way that's easily readable, and not hashes
        --friendly)
            echo "${URL}/${ISO}";;
        --download)
            echo "${URL}/${ISO}" "${HASH}";;
    esac
}


# Everything below here should not have to be modified. Variables above are used to determine the proper behavior
function validate_re() {
    ARCH="${2}"
    fetch_info
    local RELEASE="${3}"
    local EDITION="${4}"
    
    if [ -z "${RELEASE}" ]; then
        echo "ERROR! You must specify a release."
        format_re
        exit 1
    fi

    # Check if release is present in the releases array
    for REL in "${RELEASES[@]}"; do
        if [ "${RELEASE,,}" == "${REL,,}" ]; then
            # Handle unnecessary editions passed
            if [ -z "${EDITIONS[*]}" ] && [ -n "${EDITION}" ]; then
                echo "WARNING: ${PRETTY_NAME} does not support ${EDITION_NAME,,}. Ignoring."
                exit 2
            elif [ -z "${EDITION}" ] && [ "${REQUIRES_EDITION}" -eq 0 ]; then
                exit 2
            elif [ -z "${EDITION}" ] && [ "${REQUIRES_EDITION}" -eq 1 ]; then
                echo -en "ERROR: You must specify an edition.\n - ${PRETTY_NAME} ${RELEASE} Editions: "
                list_editions "${ARCH}" "${RELEASE}"
                exit 1
            fi

            # Handle the associative array for unique editions
            if [ "${UNIQUE_EDITIONS}" -eq 1 ]; then
                while read -d ';' -r aEDITION; do
                    EDITIONS+=("${aEDITION}")
                done <<< "${associativeEDITIONS["${RELEASE}"]};"
            fi

            # Loop through editions array and check if the edition is present
            for ED in "${EDITIONS[@]}"; do
                if [ "${EDITION,,}" == "${ED,,}" ]; then
                    exit 0
                fi
            done

            echo -e "ERROR! ${EDITION} is not a supported ${PRETTY_NAME} ${RELEASE} edition.\n"
            list_editions "${ARCH}" "${RELEASE}"
            exit 1
        fi
    done

    echo "ERROR! ${PRETTY_NAME} ${RELEASE} is not a supported release."
    format_re 
    exit 1
}

function format_re() {
    if [ "${UNIQUE_EDITIONS}" -eq 1 ]; then
        echo PLACEHOLDER
    else
        echo PLACEHOLDER
    fi

    echo PLACEHOLDER
}

function list_editions() {
    local RELEASE="${3}"
    # Handle the associative array for unique editions
    if [ "${UNIQUE_EDITIONS}" -eq 1 ]; then
        while read -d ';' -r aEDITION; do
            EDITIONS+=("${aEDITION}")
        done <<< "${associativeEDITIONS["${RELEASE}"]};"
    fi
    echo "${EDITIONS[@]}"
}

function fetch_from_cache() {
    echo PLACEHOLDER
}

function populate_cache() {
    echo PLACEHOLDER
}

# Set default values (should not edit)
PRETTY_NAME="${PRETTY_NAME:-$(basename "${0}" | sed 's/.os$//g')}"
EDITION_NAME="${EDITION_NAME:-Editions}"
CACHE_FILE="${HOME}/.quickget/$(basename "${0}" | sed 's/.os$//g').cache"

case "${1}" in
    --homepage)
        echo "${HOMEPAGE}";;
    --edition-name)
        echo "${EDITION_NAME}";;
    --unique-editions)
        return "${UNIQUE_EDITIONS}";;
    --pretty-name)
        return "${PRETTY_NAME}";;
    --refresh)
        fetch_info --refresh "${2}";;
    --validate-re)
        validate_re "${@}";;
    --list-urls)
        list_urls "${@}";;
esac